// This file was generated by github.com/nelsam/hel.  Do not
// edit this code by hand unless you *really* know what you're
// doing.  Expect any changes made manually to be overwritten
// the next time hel regenerates this file.

package raft_test

import (
	"golang.org/x/net/context"

	"github.com/poy/talaria/api/intra"
	rafthashi "github.com/hashicorp/raft"
	"google.golang.org/grpc"
)

type mockClientFetcher struct {
	FetchCalled chan bool
	FetchInput  struct {
		Target chan string
	}
	FetchOutput struct {
		Ret0 chan intra.NodeRaftClient
	}
}

func newMockClientFetcher() *mockClientFetcher {
	m := &mockClientFetcher{}
	m.FetchCalled = make(chan bool, 100)
	m.FetchInput.Target = make(chan string, 100)
	m.FetchOutput.Ret0 = make(chan intra.NodeRaftClient, 100)
	return m
}
func (m *mockClientFetcher) Fetch(target string) intra.NodeRaftClient {
	m.FetchCalled <- true
	m.FetchInput.Target <- target
	return <-m.FetchOutput.Ret0
}

type mockBufferReader struct {
	ReadAtCalled chan bool
	ReadAtInput  struct {
		ReadIndex chan uint64
	}
	ReadAtOutput struct {
		Ret0 chan *rafthashi.Log
		Ret1 chan uint64
		Ret2 chan error
	}
}

func newMockBufferReader() *mockBufferReader {
	m := &mockBufferReader{}
	m.ReadAtCalled = make(chan bool, 100)
	m.ReadAtInput.ReadIndex = make(chan uint64, 100)
	m.ReadAtOutput.Ret0 = make(chan *rafthashi.Log, 100)
	m.ReadAtOutput.Ret1 = make(chan uint64, 100)
	m.ReadAtOutput.Ret2 = make(chan error, 100)
	return m
}
func (m *mockBufferReader) ReadAt(readIndex uint64) (*rafthashi.Log, uint64, error) {
	m.ReadAtCalled <- true
	m.ReadAtInput.ReadIndex <- readIndex
	return <-m.ReadAtOutput.Ret0, <-m.ReadAtOutput.Ret1, <-m.ReadAtOutput.Ret2
}

type mockNodeClient struct {
	CreateCalled chan bool
	CreateInput  struct {
		Ctx  chan context.Context
		In   chan *intra.CreateInfo
		Opts chan []grpc.CallOption
	}
	CreateOutput struct {
		Ret0 chan *intra.CreateResponse
		Ret1 chan error
	}
	LeaderCalled chan bool
	LeaderInput  struct {
		Ctx  chan context.Context
		In   chan *intra.LeaderRequest
		Opts chan []grpc.CallOption
	}
	LeaderOutput struct {
		Ret0 chan *intra.LeaderResponse
		Ret1 chan error
	}
	UpdateConfigCalled chan bool
	UpdateConfigInput  struct {
		Ctx  chan context.Context
		In   chan *intra.UpdateConfigRequest
		Opts chan []grpc.CallOption
	}
	UpdateConfigOutput struct {
		Ret0 chan *intra.UpdateConfigResponse
		Ret1 chan error
	}
	AppendEntriesCalled chan bool
	AppendEntriesInput  struct {
		Ctx  chan context.Context
		In   chan *intra.AppendEntriesRequest
		Opts chan []grpc.CallOption
	}
	AppendEntriesOutput struct {
		Ret0 chan *intra.AppendEntriesResponse
		Ret1 chan error
	}
	StatusCalled chan bool
	StatusInput  struct {
		Ctx  chan context.Context
		In   chan *intra.StatusRequest
		Opts chan []grpc.CallOption
	}
	StatusOutput struct {
		Ret0 chan *intra.StatusResponse
		Ret1 chan error
	}
}

func newMockNodeClient() *mockNodeClient {
	m := &mockNodeClient{}
	m.CreateCalled = make(chan bool, 100)
	m.CreateInput.Ctx = make(chan context.Context, 100)
	m.CreateInput.In = make(chan *intra.CreateInfo, 100)
	m.CreateInput.Opts = make(chan []grpc.CallOption, 100)
	m.CreateOutput.Ret0 = make(chan *intra.CreateResponse, 100)
	m.CreateOutput.Ret1 = make(chan error, 100)
	m.LeaderCalled = make(chan bool, 100)
	m.LeaderInput.Ctx = make(chan context.Context, 100)
	m.LeaderInput.In = make(chan *intra.LeaderRequest, 100)
	m.LeaderInput.Opts = make(chan []grpc.CallOption, 100)
	m.LeaderOutput.Ret0 = make(chan *intra.LeaderResponse, 100)
	m.LeaderOutput.Ret1 = make(chan error, 100)
	m.UpdateConfigCalled = make(chan bool, 100)
	m.UpdateConfigInput.Ctx = make(chan context.Context, 100)
	m.UpdateConfigInput.In = make(chan *intra.UpdateConfigRequest, 100)
	m.UpdateConfigInput.Opts = make(chan []grpc.CallOption, 100)
	m.UpdateConfigOutput.Ret0 = make(chan *intra.UpdateConfigResponse, 100)
	m.UpdateConfigOutput.Ret1 = make(chan error, 100)
	m.AppendEntriesCalled = make(chan bool, 100)
	m.AppendEntriesInput.Ctx = make(chan context.Context, 100)
	m.AppendEntriesInput.In = make(chan *intra.AppendEntriesRequest, 100)
	m.AppendEntriesInput.Opts = make(chan []grpc.CallOption, 100)
	m.AppendEntriesOutput.Ret0 = make(chan *intra.AppendEntriesResponse, 100)
	m.AppendEntriesOutput.Ret1 = make(chan error, 100)
	m.StatusCalled = make(chan bool, 100)
	m.StatusInput.Ctx = make(chan context.Context, 100)
	m.StatusInput.In = make(chan *intra.StatusRequest, 100)
	m.StatusInput.Opts = make(chan []grpc.CallOption, 100)
	m.StatusOutput.Ret0 = make(chan *intra.StatusResponse, 100)
	m.StatusOutput.Ret1 = make(chan error, 100)
	return m
}
func (m *mockNodeClient) Create(ctx context.Context, in *intra.CreateInfo, opts ...grpc.CallOption) (*intra.CreateResponse, error) {
	m.CreateCalled <- true
	m.CreateInput.Ctx <- ctx
	m.CreateInput.In <- in
	m.CreateInput.Opts <- opts
	return <-m.CreateOutput.Ret0, <-m.CreateOutput.Ret1
}
func (m *mockNodeClient) Leader(ctx context.Context, in *intra.LeaderRequest, opts ...grpc.CallOption) (*intra.LeaderResponse, error) {
	m.LeaderCalled <- true
	m.LeaderInput.Ctx <- ctx
	m.LeaderInput.In <- in
	m.LeaderInput.Opts <- opts
	return <-m.LeaderOutput.Ret0, <-m.LeaderOutput.Ret1
}
func (m *mockNodeClient) UpdateConfig(ctx context.Context, in *intra.UpdateConfigRequest, opts ...grpc.CallOption) (*intra.UpdateConfigResponse, error) {
	m.UpdateConfigCalled <- true
	m.UpdateConfigInput.Ctx <- ctx
	m.UpdateConfigInput.In <- in
	m.UpdateConfigInput.Opts <- opts
	return <-m.UpdateConfigOutput.Ret0, <-m.UpdateConfigOutput.Ret1
}
func (m *mockNodeClient) AppendEntries(ctx context.Context, in *intra.AppendEntriesRequest, opts ...grpc.CallOption) (*intra.AppendEntriesResponse, error) {
	m.AppendEntriesCalled <- true
	m.AppendEntriesInput.Ctx <- ctx
	m.AppendEntriesInput.In <- in
	m.AppendEntriesInput.Opts <- opts
	return <-m.AppendEntriesOutput.Ret0, <-m.AppendEntriesOutput.Ret1
}
func (m *mockNodeClient) Status(ctx context.Context, in *intra.StatusRequest, opts ...grpc.CallOption) (*intra.StatusResponse, error) {
	m.StatusCalled <- true
	m.StatusInput.Ctx <- ctx
	m.StatusInput.In <- in
	m.StatusInput.Opts <- opts
	return <-m.StatusOutput.Ret0, <-m.StatusOutput.Ret1
}

type mockNodeRaftServer struct {
	AppendEntriesCalled chan bool
	AppendEntriesInput  struct {
		Arg0 chan context.Context
		Arg1 chan *intra.AppendEntriesRequest
	}
	AppendEntriesOutput struct {
		Ret0 chan *intra.AppendEntriesResponse
		Ret1 chan error
	}
	RequestVoteCalled chan bool
	RequestVoteInput  struct {
		Arg0 chan context.Context
		Arg1 chan *intra.RequestVoteRequest
	}
	RequestVoteOutput struct {
		Ret0 chan *intra.RequestVoteResponse
		Ret1 chan error
	}
}

func newMockNodeRaftServer() *mockNodeRaftServer {
	m := &mockNodeRaftServer{}
	m.AppendEntriesCalled = make(chan bool, 100)
	m.AppendEntriesInput.Arg0 = make(chan context.Context, 100)
	m.AppendEntriesInput.Arg1 = make(chan *intra.AppendEntriesRequest, 100)
	m.AppendEntriesOutput.Ret0 = make(chan *intra.AppendEntriesResponse, 100)
	m.AppendEntriesOutput.Ret1 = make(chan error, 100)
	m.RequestVoteCalled = make(chan bool, 100)
	m.RequestVoteInput.Arg0 = make(chan context.Context, 100)
	m.RequestVoteInput.Arg1 = make(chan *intra.RequestVoteRequest, 100)
	m.RequestVoteOutput.Ret0 = make(chan *intra.RequestVoteResponse, 100)
	m.RequestVoteOutput.Ret1 = make(chan error, 100)

	return m
}
func (m *mockNodeRaftServer) AppendEntries(arg0 context.Context, arg1 *intra.AppendEntriesRequest) (*intra.AppendEntriesResponse, error) {
	m.AppendEntriesCalled <- true
	m.AppendEntriesInput.Arg0 <- arg0
	m.AppendEntriesInput.Arg1 <- arg1
	return <-m.AppendEntriesOutput.Ret0, <-m.AppendEntriesOutput.Ret1
}
func (m *mockNodeRaftServer) RequestVote(arg0 context.Context, arg1 *intra.RequestVoteRequest) (*intra.RequestVoteResponse, error) {
	m.RequestVoteCalled <- true
	m.RequestVoteInput.Arg0 <- arg0
	m.RequestVoteInput.Arg1 <- arg1
	return <-m.RequestVoteOutput.Ret0, <-m.RequestVoteOutput.Ret1
}

type mockConsumerFetcher struct {
	FetchCalled chan bool
	FetchInput  struct {
		BufferName chan string
	}
	FetchOutput struct {
		Ret0 chan (<-chan rafthashi.RPC)
	}
}

func newMockConsumerFetcher() *mockConsumerFetcher {
	m := &mockConsumerFetcher{}
	m.FetchCalled = make(chan bool, 100)
	m.FetchInput.BufferName = make(chan string, 100)
	m.FetchOutput.Ret0 = make(chan (<-chan rafthashi.RPC), 100)
	return m
}
func (m *mockConsumerFetcher) Fetch(bufferName string) <-chan rafthashi.RPC {
	m.FetchCalled <- true
	m.FetchInput.BufferName <- bufferName
	return <-m.FetchOutput.Ret0
}

type mockNode struct {
	AddPeerCalled chan bool
	AddPeerInput  struct {
		Peer chan string
	}
	AddPeerOutput struct {
		Ret0 chan rafthashi.Future
	}
	RemovePeerCalled chan bool
	RemovePeerInput  struct {
		Peer chan string
	}
	RemovePeerOutput struct {
		Ret0 chan rafthashi.Future
	}
}

func newMockNode() *mockNode {
	m := &mockNode{}
	m.AddPeerCalled = make(chan bool, 100)
	m.AddPeerInput.Peer = make(chan string, 100)
	m.AddPeerOutput.Ret0 = make(chan rafthashi.Future, 100)
	m.RemovePeerCalled = make(chan bool, 100)
	m.RemovePeerInput.Peer = make(chan string, 100)
	m.RemovePeerOutput.Ret0 = make(chan rafthashi.Future, 100)
	return m
}
func (m *mockNode) AddPeer(peer string) rafthashi.Future {
	m.AddPeerCalled <- true
	m.AddPeerInput.Peer <- peer
	return <-m.AddPeerOutput.Ret0
}
func (m *mockNode) RemovePeer(peer string) rafthashi.Future {
	m.RemovePeerCalled <- true
	m.RemovePeerInput.Peer <- peer
	return <-m.RemovePeerOutput.Ret0
}

type mockPeerStore struct {
	PeersCalled chan bool
	PeersOutput struct {
		Ret0 chan []string
		Ret1 chan error
	}
	SetPeersCalled chan bool
	SetPeersInput  struct {
		Arg0 chan []string
	}
	SetPeersOutput struct {
		Ret0 chan error
	}
}

func newMockPeerStore() *mockPeerStore {
	m := &mockPeerStore{}
	m.PeersCalled = make(chan bool, 100)
	m.PeersOutput.Ret0 = make(chan []string, 100)
	m.PeersOutput.Ret1 = make(chan error, 100)
	m.SetPeersCalled = make(chan bool, 100)
	m.SetPeersInput.Arg0 = make(chan []string, 100)
	m.SetPeersOutput.Ret0 = make(chan error, 100)
	return m
}
func (m *mockPeerStore) Peers() ([]string, error) {
	m.PeersCalled <- true
	return <-m.PeersOutput.Ret0, <-m.PeersOutput.Ret1
}
func (m *mockPeerStore) SetPeers(arg0 []string) error {
	m.SetPeersCalled <- true
	m.SetPeersInput.Arg0 <- arg0
	return <-m.SetPeersOutput.Ret0
}
