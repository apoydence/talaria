// This file was generated by github.com/nelsam/hel.  Do not
// edit this code by hand unless you *really* know what you're
// doing.  Expect any changes made manually to be overwritten
// the next time hel regenerates this file.

package network_test

import (
	"golang.org/x/net/context"

	"github.com/apoydence/talaria/api/intra"
	rafthashi "github.com/hashicorp/raft"
	"google.golang.org/grpc"
)

type mockBufferReader struct {
	ReadAtCalled chan bool
	ReadAtInput  struct {
		ReadIndex chan uint64
	}
	ReadAtOutput struct {
		Ret0 chan *rafthashi.Log
		Ret1 chan uint64
		Ret2 chan error
	}
}

func newMockBufferReader() *mockBufferReader {
	m := &mockBufferReader{}
	m.ReadAtCalled = make(chan bool, 100)
	m.ReadAtInput.ReadIndex = make(chan uint64, 100)
	m.ReadAtOutput.Ret0 = make(chan *rafthashi.Log, 100)
	m.ReadAtOutput.Ret1 = make(chan uint64, 100)
	m.ReadAtOutput.Ret2 = make(chan error, 100)
	return m
}
func (m *mockBufferReader) ReadAt(readIndex uint64) (*rafthashi.Log, uint64, error) {
	m.ReadAtCalled <- true
	m.ReadAtInput.ReadIndex <- readIndex
	return <-m.ReadAtOutput.Ret0, <-m.ReadAtOutput.Ret1, <-m.ReadAtOutput.Ret2
}

type mockNodeClient struct {
	CreateCalled chan bool
	CreateInput  struct {
		Ctx  chan context.Context
		In   chan *intra.CreateInfo
		Opts chan []grpc.CallOption
	}
	CreateOutput struct {
		Ret0 chan *intra.CreateResponse
		Ret1 chan error
	}
	LeaderCalled chan bool
	LeaderInput  struct {
		Ctx  chan context.Context
		In   chan *intra.LeaderRequest
		Opts chan []grpc.CallOption
	}
	LeaderOutput struct {
		Ret0 chan *intra.LeaderResponse
		Ret1 chan error
	}
	UpdateConfigCalled chan bool
	UpdateConfigInput  struct {
		Ctx  chan context.Context
		In   chan *intra.UpdateConfigRequest
		Opts chan []grpc.CallOption
	}
	UpdateConfigOutput struct {
		Ret0 chan *intra.UpdateConfigResponse
		Ret1 chan error
	}
	AppendEntriesCalled chan bool
	AppendEntriesInput  struct {
		Ctx  chan context.Context
		In   chan *intra.AppendEntriesRequest
		Opts chan []grpc.CallOption
	}
	AppendEntriesOutput struct {
		Ret0 chan *intra.AppendEntriesResponse
		Ret1 chan error
	}
	StatusCalled chan bool
	StatusInput  struct {
		Ctx  chan context.Context
		In   chan *intra.StatusRequest
		Opts chan []grpc.CallOption
	}
	StatusOutput struct {
		Ret0 chan *intra.StatusResponse
		Ret1 chan error
	}
}

func newMockNodeClient() *mockNodeClient {
	m := &mockNodeClient{}
	m.CreateCalled = make(chan bool, 100)
	m.CreateInput.Ctx = make(chan context.Context, 100)
	m.CreateInput.In = make(chan *intra.CreateInfo, 100)
	m.CreateInput.Opts = make(chan []grpc.CallOption, 100)
	m.CreateOutput.Ret0 = make(chan *intra.CreateResponse, 100)
	m.CreateOutput.Ret1 = make(chan error, 100)
	m.LeaderCalled = make(chan bool, 100)
	m.LeaderInput.Ctx = make(chan context.Context, 100)
	m.LeaderInput.In = make(chan *intra.LeaderRequest, 100)
	m.LeaderInput.Opts = make(chan []grpc.CallOption, 100)
	m.LeaderOutput.Ret0 = make(chan *intra.LeaderResponse, 100)
	m.LeaderOutput.Ret1 = make(chan error, 100)
	m.UpdateConfigCalled = make(chan bool, 100)
	m.UpdateConfigInput.Ctx = make(chan context.Context, 100)
	m.UpdateConfigInput.In = make(chan *intra.UpdateConfigRequest, 100)
	m.UpdateConfigInput.Opts = make(chan []grpc.CallOption, 100)
	m.UpdateConfigOutput.Ret0 = make(chan *intra.UpdateConfigResponse, 100)
	m.UpdateConfigOutput.Ret1 = make(chan error, 100)
	m.AppendEntriesCalled = make(chan bool, 100)
	m.AppendEntriesInput.Ctx = make(chan context.Context, 100)
	m.AppendEntriesInput.In = make(chan *intra.AppendEntriesRequest, 100)
	m.AppendEntriesInput.Opts = make(chan []grpc.CallOption, 100)
	m.AppendEntriesOutput.Ret0 = make(chan *intra.AppendEntriesResponse, 100)
	m.AppendEntriesOutput.Ret1 = make(chan error, 100)
	m.StatusCalled = make(chan bool, 100)
	m.StatusInput.Ctx = make(chan context.Context, 100)
	m.StatusInput.In = make(chan *intra.StatusRequest, 100)
	m.StatusInput.Opts = make(chan []grpc.CallOption, 100)
	m.StatusOutput.Ret0 = make(chan *intra.StatusResponse, 100)
	m.StatusOutput.Ret1 = make(chan error, 100)
	return m
}
func (m *mockNodeClient) Create(ctx context.Context, in *intra.CreateInfo) (*intra.CreateResponse, error) {
	m.CreateCalled <- true
	m.CreateInput.Ctx <- ctx
	m.CreateInput.In <- in
	return <-m.CreateOutput.Ret0, <-m.CreateOutput.Ret1
}
func (m *mockNodeClient) Leader(ctx context.Context, in *intra.LeaderRequest) (*intra.LeaderResponse, error) {
	m.LeaderCalled <- true
	m.LeaderInput.Ctx <- ctx
	m.LeaderInput.In <- in
	return <-m.LeaderOutput.Ret0, <-m.LeaderOutput.Ret1
}
func (m *mockNodeClient) UpdateConfig(ctx context.Context, in *intra.UpdateConfigRequest) (*intra.UpdateConfigResponse, error) {
	m.UpdateConfigCalled <- true
	m.UpdateConfigInput.Ctx <- ctx
	m.UpdateConfigInput.In <- in
	return <-m.UpdateConfigOutput.Ret0, <-m.UpdateConfigOutput.Ret1
}
func (m *mockNodeClient) AppendEntries(ctx context.Context, in *intra.AppendEntriesRequest, opts ...grpc.CallOption) (*intra.AppendEntriesResponse, error) {
	m.AppendEntriesCalled <- true
	m.AppendEntriesInput.Ctx <- ctx
	m.AppendEntriesInput.In <- in
	m.AppendEntriesInput.Opts <- opts
	return <-m.AppendEntriesOutput.Ret0, <-m.AppendEntriesOutput.Ret1
}
func (m *mockNodeClient) Status(ctx context.Context, in *intra.StatusRequest) (*intra.StatusResponse, error) {
	m.StatusCalled <- true
	m.StatusInput.Ctx <- ctx
	m.StatusInput.In <- in
	return <-m.StatusOutput.Ret0, <-m.StatusOutput.Ret1
}

type mockNodeRaftServer struct {
	AppendEntriesCalled chan bool
	AppendEntriesInput  struct {
		Arg0 chan context.Context
		Arg1 chan *intra.AppendEntriesRequest
	}
	AppendEntriesOutput struct {
		Ret0 chan *intra.AppendEntriesResponse
		Ret1 chan error
	}
	RequestVoteCalled chan bool
	RequestVoteInput  struct {
		Arg0 chan context.Context
		Arg1 chan *intra.RequestVoteRequest
	}
	RequestVoteOutput struct {
		Ret0 chan *intra.RequestVoteResponse
		Ret1 chan error
	}
}

func newMockNodeRaftServer() *mockNodeRaftServer {
	m := &mockNodeRaftServer{}
	m.AppendEntriesCalled = make(chan bool, 100)
	m.AppendEntriesInput.Arg0 = make(chan context.Context, 100)
	m.AppendEntriesInput.Arg1 = make(chan *intra.AppendEntriesRequest, 100)
	m.AppendEntriesOutput.Ret0 = make(chan *intra.AppendEntriesResponse, 100)
	m.AppendEntriesOutput.Ret1 = make(chan error, 100)
	m.RequestVoteCalled = make(chan bool, 100)
	m.RequestVoteInput.Arg0 = make(chan context.Context, 100)
	m.RequestVoteInput.Arg1 = make(chan *intra.RequestVoteRequest, 100)
	m.RequestVoteOutput.Ret0 = make(chan *intra.RequestVoteResponse, 100)
	m.RequestVoteOutput.Ret1 = make(chan error, 100)

	return m
}
func (m *mockNodeRaftServer) AppendEntries(arg0 context.Context, arg1 *intra.AppendEntriesRequest) (*intra.AppendEntriesResponse, error) {
	m.AppendEntriesCalled <- true
	m.AppendEntriesInput.Arg0 <- arg0
	m.AppendEntriesInput.Arg1 <- arg1
	return <-m.AppendEntriesOutput.Ret0, <-m.AppendEntriesOutput.Ret1
}
func (m *mockNodeRaftServer) RequestVote(arg0 context.Context, arg1 *intra.RequestVoteRequest) (*intra.RequestVoteResponse, error) {
	m.RequestVoteCalled <- true
	m.RequestVoteInput.Arg0 <- arg0
	m.RequestVoteInput.Arg1 <- arg1
	return <-m.RequestVoteOutput.Ret0, <-m.RequestVoteOutput.Ret1
}

type mockConsumerFetcher struct {
	FetchCalled chan bool
	FetchInput  struct {
		BufferName chan string
	}
	FetchOutput struct {
		Ret0 chan (<-chan rafthashi.RPC)
	}
}

func newMockConsumerFetcher() *mockConsumerFetcher {
	m := &mockConsumerFetcher{}
	m.FetchCalled = make(chan bool, 100)
	m.FetchInput.BufferName = make(chan string, 100)
	m.FetchOutput.Ret0 = make(chan (<-chan rafthashi.RPC), 100)
	return m
}
func (m *mockConsumerFetcher) Fetch(bufferName string) <-chan rafthashi.RPC {
	m.FetchCalled <- true
	m.FetchInput.BufferName <- bufferName
	return <-m.FetchOutput.Ret0
}

type mockNodeRaftClient struct {
	AppendEntriesCalled chan bool
	AppendEntriesInput  struct {
		Ctx  chan context.Context
		In   chan *intra.AppendEntriesRequest
		Opts chan []grpc.CallOption
	}
	AppendEntriesOutput struct {
		Ret0 chan *intra.AppendEntriesResponse
		Ret1 chan error
	}
	RequestVoteCalled chan bool
	RequestVoteInput  struct {
		Ctx  chan context.Context
		In   chan *intra.RequestVoteRequest
		Opts chan []grpc.CallOption
	}
	RequestVoteOutput struct {
		Ret0 chan *intra.RequestVoteResponse
		Ret1 chan error
	}
}

func newMockNodeRaftClient() *mockNodeRaftClient {
	m := &mockNodeRaftClient{}
	m.AppendEntriesCalled = make(chan bool, 100)
	m.AppendEntriesInput.Ctx = make(chan context.Context, 100)
	m.AppendEntriesInput.In = make(chan *intra.AppendEntriesRequest, 100)
	m.AppendEntriesInput.Opts = make(chan []grpc.CallOption, 100)
	m.AppendEntriesOutput.Ret0 = make(chan *intra.AppendEntriesResponse, 100)
	m.AppendEntriesOutput.Ret1 = make(chan error, 100)
	m.RequestVoteCalled = make(chan bool, 100)
	m.RequestVoteInput.Ctx = make(chan context.Context, 100)
	m.RequestVoteInput.In = make(chan *intra.RequestVoteRequest, 100)
	m.RequestVoteInput.Opts = make(chan []grpc.CallOption, 100)
	m.RequestVoteOutput.Ret0 = make(chan *intra.RequestVoteResponse, 100)
	m.RequestVoteOutput.Ret1 = make(chan error, 100)
	return m
}
func (m *mockNodeRaftClient) AppendEntries(ctx context.Context, in *intra.AppendEntriesRequest, opts ...grpc.CallOption) (*intra.AppendEntriesResponse, error) {
	m.AppendEntriesCalled <- true
	m.AppendEntriesInput.Ctx <- ctx
	m.AppendEntriesInput.In <- in
	m.AppendEntriesInput.Opts <- opts
	return <-m.AppendEntriesOutput.Ret0, <-m.AppendEntriesOutput.Ret1
}
func (m *mockNodeRaftClient) RequestVote(ctx context.Context, in *intra.RequestVoteRequest, opts ...grpc.CallOption) (*intra.RequestVoteResponse, error) {
	m.RequestVoteCalled <- true
	m.RequestVoteInput.Ctx <- ctx
	m.RequestVoteInput.In <- in
	m.RequestVoteInput.Opts <- opts
	return <-m.RequestVoteOutput.Ret0, <-m.RequestVoteOutput.Ret1
}

type mockIOFetcher struct {
	CreateCalled chan bool
	CreateInput  struct {
		Name  chan string
		Peers chan []string
	}
	CreateOutput struct {
		Ret0 chan error
	}
	LeaderCalled chan bool
	LeaderInput  struct {
		Name chan string
	}
	LeaderOutput struct {
		Ret0 chan string
		Ret1 chan error
	}
	StatusCalled chan bool
	StatusOutput struct {
		Ret0 chan map[string][]string
	}
	SetExpectedPeersCalled chan bool
	SetExpectedPeersInput  struct {
		Name          chan string
		ExpectedPeers chan []string
	}
	SetExpectedPeersOutput struct {
		Ret0 chan error
	}
}

func newMockIOFetcher() *mockIOFetcher {
	m := &mockIOFetcher{}
	m.CreateCalled = make(chan bool, 100)
	m.CreateInput.Name = make(chan string, 100)
	m.CreateInput.Peers = make(chan []string, 100)
	m.CreateOutput.Ret0 = make(chan error, 100)
	m.LeaderCalled = make(chan bool, 100)
	m.LeaderInput.Name = make(chan string, 100)
	m.LeaderOutput.Ret0 = make(chan string, 100)
	m.LeaderOutput.Ret1 = make(chan error, 100)
	m.StatusCalled = make(chan bool, 100)
	m.StatusOutput.Ret0 = make(chan map[string][]string, 100)
	m.SetExpectedPeersCalled = make(chan bool, 100)
	m.SetExpectedPeersInput.Name = make(chan string, 100)
	m.SetExpectedPeersInput.ExpectedPeers = make(chan []string, 100)
	m.SetExpectedPeersOutput.Ret0 = make(chan error, 100)
	return m
}
func (m *mockIOFetcher) Create(name string, peers []string) error {
	m.CreateCalled <- true
	m.CreateInput.Name <- name
	m.CreateInput.Peers <- peers
	return <-m.CreateOutput.Ret0
}
func (m *mockIOFetcher) Leader(name string) (string, error) {
	m.LeaderCalled <- true
	m.LeaderInput.Name <- name
	return <-m.LeaderOutput.Ret0, <-m.LeaderOutput.Ret1
}
func (m *mockIOFetcher) Status() map[string][]string {
	m.StatusCalled <- true
	return <-m.StatusOutput.Ret0
}
func (m *mockIOFetcher) SetExpectedPeers(name string, expectedPeers []string) error {
	m.SetExpectedPeersCalled <- true
	m.SetExpectedPeersInput.Name <- name
	m.SetExpectedPeersInput.ExpectedPeers <- expectedPeers
	return <-m.SetExpectedPeersOutput.Ret0
}
