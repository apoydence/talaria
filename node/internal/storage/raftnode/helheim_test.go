// This file was generated by github.com/nelsam/hel.  Do not
// edit this code by hand unless you *really* know what you're
// doing.  Expect any changes made manually to be overwritten
// the next time hel regenerates this file.

package raftnode_test

import "github.com/coreos/etcd/raft/raftpb"

type mockStorage struct {
	InitialStateCalled chan bool
	InitialStateOutput struct {
		Ret0 chan raftpb.HardState
		Ret1 chan raftpb.ConfState
		Ret2 chan error
	}
	EntriesCalled chan bool
	EntriesInput  struct {
		Lo, Hi, MaxSize chan uint64
	}
	EntriesOutput struct {
		Ret0 chan []raftpb.Entry
		Ret1 chan error
	}
	TermCalled chan bool
	TermInput  struct {
		I chan uint64
	}
	TermOutput struct {
		Ret0 chan uint64
		Ret1 chan error
	}
	LastIndexCalled chan bool
	LastIndexOutput struct {
		Ret0 chan uint64
		Ret1 chan error
	}
	FirstIndexCalled chan bool
	FirstIndexOutput struct {
		Ret0 chan uint64
		Ret1 chan error
	}
	SnapshotCalled chan bool
	SnapshotOutput struct {
		Ret0 chan raftpb.Snapshot
		Ret1 chan error
	}
	HardStateCalled chan bool
	HardStateInput  struct {
		Arg0 chan raftpb.HardState
	}
	WriteCalled chan bool
	WriteInput  struct {
		Data chan raftpb.Entry
	}
	WriteOutput struct {
		Ret0 chan uint64
		Ret1 chan error
	}
	ReadAtCalled chan bool
	ReadAtInput  struct {
		Index chan uint64
	}
	ReadAtOutput struct {
		Ret0 chan raftpb.Entry
		Ret1 chan uint64
		Ret2 chan error
	}
}

func newMockStorage() *mockStorage {
	m := &mockStorage{}
	m.InitialStateCalled = make(chan bool, 100)
	m.InitialStateOutput.Ret0 = make(chan raftpb.HardState, 100)
	m.InitialStateOutput.Ret1 = make(chan raftpb.ConfState, 100)
	m.InitialStateOutput.Ret2 = make(chan error, 100)
	m.EntriesCalled = make(chan bool, 100)
	m.EntriesInput.Lo = make(chan uint64, 100)
	m.EntriesInput.Hi = make(chan uint64, 100)
	m.EntriesInput.MaxSize = make(chan uint64, 100)
	m.EntriesOutput.Ret0 = make(chan []raftpb.Entry, 100)
	m.EntriesOutput.Ret1 = make(chan error, 100)
	m.TermCalled = make(chan bool, 100)
	m.TermInput.I = make(chan uint64, 100)
	m.TermOutput.Ret0 = make(chan uint64, 100)
	m.TermOutput.Ret1 = make(chan error, 100)
	m.LastIndexCalled = make(chan bool, 100)
	m.LastIndexOutput.Ret0 = make(chan uint64, 100)
	m.LastIndexOutput.Ret1 = make(chan error, 100)
	m.FirstIndexCalled = make(chan bool, 100)
	m.FirstIndexOutput.Ret0 = make(chan uint64, 100)
	m.FirstIndexOutput.Ret1 = make(chan error, 100)
	m.SnapshotCalled = make(chan bool, 100)
	m.SnapshotOutput.Ret0 = make(chan raftpb.Snapshot, 100)
	m.SnapshotOutput.Ret1 = make(chan error, 100)
	m.HardStateCalled = make(chan bool, 100)
	m.HardStateInput.Arg0 = make(chan raftpb.HardState, 100)
	m.WriteCalled = make(chan bool, 100)
	m.WriteInput.Data = make(chan raftpb.Entry, 100)
	m.WriteOutput.Ret0 = make(chan uint64, 100)
	m.WriteOutput.Ret1 = make(chan error, 100)
	m.ReadAtCalled = make(chan bool, 100)
	m.ReadAtInput.Index = make(chan uint64, 100)
	m.ReadAtOutput.Ret0 = make(chan raftpb.Entry, 100)
	m.ReadAtOutput.Ret1 = make(chan uint64, 100)
	m.ReadAtOutput.Ret2 = make(chan error, 100)
	return m
}
func (m *mockStorage) InitialState() (raftpb.HardState, raftpb.ConfState, error) {
	m.InitialStateCalled <- true
	return <-m.InitialStateOutput.Ret0, <-m.InitialStateOutput.Ret1, <-m.InitialStateOutput.Ret2
}
func (m *mockStorage) Entries(lo, hi, maxSize uint64) ([]raftpb.Entry, error) {
	m.EntriesCalled <- true
	m.EntriesInput.Lo <- lo
	m.EntriesInput.Hi <- hi
	m.EntriesInput.MaxSize <- maxSize
	return <-m.EntriesOutput.Ret0, <-m.EntriesOutput.Ret1
}
func (m *mockStorage) Term(i uint64) (uint64, error) {
	m.TermCalled <- true
	m.TermInput.I <- i
	return <-m.TermOutput.Ret0, <-m.TermOutput.Ret1
}
func (m *mockStorage) LastIndex() (uint64, error) {
	m.LastIndexCalled <- true
	return <-m.LastIndexOutput.Ret0, <-m.LastIndexOutput.Ret1
}
func (m *mockStorage) FirstIndex() (uint64, error) {
	m.FirstIndexCalled <- true
	return <-m.FirstIndexOutput.Ret0, <-m.FirstIndexOutput.Ret1
}
func (m *mockStorage) Snapshot() (raftpb.Snapshot, error) {
	m.SnapshotCalled <- true
	return <-m.SnapshotOutput.Ret0, <-m.SnapshotOutput.Ret1
}
func (m *mockStorage) HardState(arg0 raftpb.HardState) {
	m.HardStateCalled <- true
	m.HardStateInput.Arg0 <- arg0
}
func (m *mockStorage) Write(data raftpb.Entry) (uint64, error) {
	m.WriteCalled <- true
	m.WriteInput.Data <- data
	return <-m.WriteOutput.Ret0, <-m.WriteOutput.Ret1
}
func (m *mockStorage) ReadAt(index uint64) (raftpb.Entry, uint64, error) {
	m.ReadAtCalled <- true
	m.ReadAtInput.Index <- index
	return <-m.ReadAtOutput.Ret0, <-m.ReadAtOutput.Ret1, <-m.ReadAtOutput.Ret2
}

type mockNetwork struct {
	RecvCalled chan bool
	RecvOutput struct {
		Ret0 chan raftpb.Message
		Ret1 chan error
	}
	EmitCalled chan bool
	EmitInput  struct {
		Msgs chan []raftpb.Message
	}
}

func newMockNetwork() *mockNetwork {
	m := &mockNetwork{}
	m.RecvCalled = make(chan bool, 100)
	m.RecvOutput.Ret0 = make(chan raftpb.Message, 100)
	m.RecvOutput.Ret1 = make(chan error, 100)
	m.EmitCalled = make(chan bool, 100)
	m.EmitInput.Msgs = make(chan []raftpb.Message, 100)
	return m
}
func (m *mockNetwork) Recv() (raftpb.Message, error) {
	m.RecvCalled <- true
	return <-m.RecvOutput.Ret0, <-m.RecvOutput.Ret1
}
func (m *mockNetwork) Emit(msgs []raftpb.Message) {
	m.EmitCalled <- true
	m.EmitInput.Msgs <- msgs
}
